package io.shiftleft.semanticcpg.passes.aliasing
import io.shiftleft.codepropertygraph.Cpg
import io.shiftleft.codepropertygraph.generated._
import io.shiftleft.passes.{CpgPass, DiffGraph}
import io.shiftleft.semanticcpg.language._
import io.shiftleft.semanticcpg.language.nodemethods.TrackingPointMethodsBase

import io.shiftleft.semanticcpg.utils.MemberAccess.isGenericMemberAccessName
import org.slf4j.LoggerFactory
import overflowdb.traversal.Traversal

object SimpleMustAliasPass {
  private val logger = LoggerFactory.getLogger(getClass)

  def getAliasPairs(method: nodes.Method): Traversal[(nodes.Identifier, nodes.Call)] = {
    for (local <- method.local if !local._closureBindingViaCapturedByOut.hasNext && !method.parameter.exists { _.name == local.name };
         (use, definition) <- getAliasPair(local))
      yield (use, definition)
  }

  private def getAliasPair(local: nodes.Local): Option[(nodes.Identifier, nodes.Call)] = {
    val refs = local._identifierViaRefIn.toList
    if (refs.size != 2) return None

    val (definitions, uses) = refs.partitionMap { identifier =>
      getAssignmentRhsIfMemberRead(identifier) match {
        case Some(call) => Left(call)
        case _          => Right(identifier)
      }
    }
    if (definitions.size == 1 && uses.size == 1) {
      val use = uses.head
      val definition = definitions.head
      if (use.argumentIndex != 1 || use._callViaArgumentIn.fold(true) { user =>
        user.name != Operators.assignment
      }) Some(use, definition)
      else None
    } else None

  }

  private def getAssignmentRhsIfMemberRead(identifier: nodes.Identifier): Option[nodes.Call] = {
    if (identifier.argumentIndex != 1) return None
    identifier._callViaArgumentIn match {
      case Some(call) if call.methodFullName == Operators.assignment =>
        call.argumentOption(2) match {
          case memberAccess: nodes.Call
            if (isGenericMemberAccessName(memberAccess.methodFullName)
              || (TrackingPointMethodsBase.experimentalCastAsMemberAccess && memberAccess.methodFullName == Operators.cast)) =>
            Some(memberAccess)
          case _ => None
        }
      case _ => None
    }
  }

}

/**
  * The SimpleMustAliasPass draws some edges between aliasing pairs of Identifiers at use-site and the right-hand-sides
  * of their definition.
  *
  * It is purely AST-based and intended for patterns like:
  *
  * val tmp = this.x
  * ...
  * taintFromSource(tmp)
  * ...
  * flowToSink(this)
  *
  * Such patterns are generated by Soot for JVM languages for code that originally looked like the following, wehere we
  * can reduce false negatives:
  *
  * taintFromSource(this.x)
  * flowToSink(this)
  *
  * The same applies for the following,
  *
  * val tmp = obj.getX()
  * taintFromSource(tmp)
  * flowToSink(obj)
  *
  * which gets effectively normalized to
  *
  * taintFromSource(obj.getX())
  * flowToSink(obj)
  *
  * and will find a flow if obj.getX() is know to return an alias to obj.x
  **
  * The same of course applies to the following, where we can reduce false positives:
  *
  * clearTaint(this.x)
  * flowToSink(this.x)
  *
  * As such, the goal of this simple pass is very narrow:
  *
  * We only apply for LOCALs that are referenced exactly twice, from the same stackframe (i.e. no closure bindings
  * involved), where the LOCAL appears exactly once as the left-hand-side of an assignment (i.e. a definition) and the
  * right-hand-side of this assignment is a member access.
  *
  * In certain patterns, this can lead to wrong flows. For example, the following will lead to a false positive:
  *
  * tmp = this.x
  * this.x = null
  * taintFromSource(tmp)
  * flowToSink(this)
  *
  * */
class SimpleMustAliasPass(cpg: Cpg) extends CpgPass(cpg) {
  import SimpleMustAliasPass._

  override def run(): Iterator[DiffGraph] = {
    val builder = DiffGraph.newBuilder
    for (method <- cpg.method;
      (use, definition) <- getAliasPairs(method)) {
      builder.addEdge(src = use, dst = definition, edgeLabel = EdgeTypes.MUST_ALIAS)
    }
    val res = builder.build
    //fixme: Make this logger.debug once people are using this pass in their pipeline.
    //until then, it is more convenient to have the raised loglevel
    logger.info(s"antiAlias pairs: ${res.size} from ${cpg.local.size}")
    Iterator(res)
  }



}
