package io.shiftleft.semanticcpg.passes.aliasing
import io.shiftleft.codepropertygraph.Cpg
import io.shiftleft.codepropertygraph.generated._
import io.shiftleft.passes.{CpgPass, DiffGraph}
import io.shiftleft.semanticcpg.language._
import io.shiftleft.semanticcpg.language.nodemethods.TrackingPointMethodsBase

import io.shiftleft.semanticcpg.utils.MemberAccess.isGenericMemberAccessName
import org.slf4j.LoggerFactory
import overflowdb.traversal.Traversal

object SimpleMustAliasPass {
  private val logger = LoggerFactory.getLogger(getClass)

  def getAliasPairs(method: nodes.Method): Traversal[(nodes.Call, nodes.Identifier)] = {
    for (local <- method.local if !local._closureBindingViaCapturedByOut.hasNext && !method.parameter.exists { _.name == local.name };
         defuse <- getAliasPair(local))
      yield defuse
  }

  private def getAliasPair(local: nodes.Local): Option[(nodes.Call, nodes.Identifier)] = {
    val (definitions, uses) = defsUses(local)
    if (definitions.size == 1 && uses.size == 1) {
      val use = uses.head
      val definition = definitions.head
      if (definition.name == Operators.cast || isGenericMemberAccessName(definition.name)) Some((definition, use))
      else None
    } else None
  }

  def defsUses(local: nodes.Local): (List[nodes.Call], List[nodes.Identifier]) = local._identifierViaRefIn.toList.partitionMap { identifier =>
    if(identifier.argumentIndex == 1)
      identifier._callViaArgumentIn match {
        case Some(call) if call.name == Operators.assignment => Left(call)
        case _=>Right(identifier)
      }
    else Right(identifier)
  }


}

/**
  * The SimpleMustAliasPass draws some edges between aliasing pairs of Identifiers at use-site and the right-hand-sides
  * of their definition.
  *
  * It is purely AST-based and intended for patterns like:
  *
  * val tmp = this.x
  * ...
  * taintFromSource(tmp)
  * ...
  * flowToSink(this)
  *
  * Such patterns are generated by Soot for JVM languages for code that originally looked like the following, wehere we
  * can reduce false negatives:
  *
  * taintFromSource(this.x)
  * flowToSink(this)
  *
  * The same applies for the following,
  *
  * val tmp = obj.getX()
  * taintFromSource(tmp)
  * flowToSink(obj)
  *
  * which gets effectively normalized to
  *
  * taintFromSource(obj.getX())
  * flowToSink(obj)
  *
  * and will find a flow if obj.getX() is know to return an alias to obj.x
  **
  * The same of course applies to the following, where we can reduce false positives:
  *
  * clearTaint(this.x)
  * flowToSink(this.x)
  *
  * As such, the goal of this simple pass is very narrow:
  *
  * We only apply for LOCALs that are referenced exactly twice, from the same stackframe (i.e. no closure bindings
  * involved), where the LOCAL appears exactly once as the left-hand-side of an assignment (i.e. a definition) and the
  * right-hand-side of this assignment is a member access.
  *
  * In certain patterns, this can lead to wrong flows. For example, the following will lead to a false positive:
  *
  * tmp = this.x
  * this.x = null
  * taintFromSource(tmp)
  * flowToSink(this)
  *
  * */
class SimpleMustAliasPass(cpg: Cpg) extends CpgPass(cpg) {
  import SimpleMustAliasPass._

  override def run(): Iterator[DiffGraph] = {
    val builder = DiffGraph.newBuilder
    for (method <- cpg.method;
      (definition, use) <- getAliasPairs(method)) {
      builder.addEdge(src = use, dst = definition, edgeLabel = EdgeTypes.MUST_ALIAS)
    }
    val res = builder.build
    //fixme: Make this logger.debug once people are using this pass in their pipeline.
    //until then, it is more convenient to have the raised loglevel
    logger.info(s"antiAlias pairs: ${res.size} from ${cpg.local.size}")
    Iterator(res)
  }



}
